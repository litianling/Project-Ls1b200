/*
 * bsp_start.S
 *
 * created: 2022/2/21
 *  author: Li TianLing
 */

/**************************************
*
*   v0  邻接矩阵arr的基地址 （常量）
*   v1  参数node_num        （常量）
*
*   t0  哨兵k（遍历允许通过的点）
*   t1  哨兵i（遍历源节点）
*   t2  哨兵j（遍历目标节点）
*
**************************************/

#include "regdef.h"
#include "cpu.h"
#include "asm.h"
#define INF 127

//-----------------------------------------------------------------------------
//数据段
    .data
    /* 一维数组保存着式3.6给出的邻接矩阵，顺序从上到下，从左到右 */
    arr:      .byte 0,1,1,INF,1,1,0,1,INF,INF,1,1,0,1,1,INF,INF,1,0,INF,1,INF,1,INF,0
    node_num:  .byte 5     //保存着顶点信息，用于循环

//-----------------------------------------------------------------------------
//代码段
    .text
LEAF(bsp_start)
	.set noreorder
     move s0, ra

    la      v0, arr           // 将一维数组的地址加载到寄存器v0中
    lb      v1, node_num      // 将node_num的值加载到寄存器v1中
    li      t0, 0             // 将寄存器t0初始化为0
    li      t1, 0             // 将寄存器t1初始化为0
    li      t2, 0             // 将寄存器t2初始化为0

/* 下面的代码执行弗洛伊德算法 */

/* 三重循环的索引从1开始 */
1:                            // 对应于最外层的循环
    addi    t0, t0, 1         // t0对应的k，(t0)+1→(t0)
2:                            // 对应于中间层的循环
    addi    t1, t1, 1         // t1对应的i，(t1)+1→(t1)
3:                            // 对应于最里层的循环
    addi    t2, t2, 1         // t2对应的j，(t2)+1→(t2)

/* 循环索引从1开始，数组arr的索引从0开始，循环索引减1匹配数组索引 */

    addiu   t7, t1, -1        // (t1)-1→(t7)
    mul     t3, t7, v1        // t3 = t7(i)×v1(node_num)

    addiu   t7, t2, -1        // (t2)-1→(t7)
    addu    t4, t3, t7        // t4 = t3 + j(t2)，计算[i][j]对应元素的偏移量

    addu    t5, t4, v0        // t5 = base(arr)+(t4)，计算[i][j]对应元素存储地址

    lb      a0, 0(t5)         // 将初始路径的值加载到寄存器a0中，arr[i][j]

    addiu    t7, t0, -1       // (t0)-1→(t7)
    addu     t4, t3, t7       // t4 = t3 + k(t7)，计算[i][k]对应元素的偏移量

    addu     t5, t4, v0       // t5 = base(arr)+t4，计算[i][k]对应元素存储地址

    lb      a1, 0(t5)         // 将arr[i][k]路径的值加载到寄存器a1

    addiu    t7, t0, -1       // (t0)-1→(t7)
    mul     t3, t7, v1        // t3 = t7(k)×node_num (v1)

    addiu    t7, t2, -1       // (t2)-1→(t7)
    addu    t4, t3, t7        // t4 = t3 + j(t7)，计算[k][j]对应元素的偏移量


    addu   t5, t4, v0         // t5 = base(arr)+t4，计算[k][j]对应元素的存储地址

    lb      a2, 0(t5)         // 将arr[k][j]路径的值加载到寄存器a2

    addu   a3, a1, a2         // (a1)+(a2)→(a3)，arr[i][k]+arr[k][j]→(a3)
    sltu    s7, a3, a0        // 判断(a3)<(a0)?，即[i][k]+[k][j]<[i][j]？
    beqz   s7, 4f             // 不成立，跳转到标号为4的位置
    nop                       // 延迟隙

    addiu   t7, t1, -1        // (t1)-1→(t7), (t1)=i
    mul     t3, t7, v1        // t3 = t7(i)×v1(node_num)

    addiu   t7, t2, -1        // (t2)-1→(t7), (t2)=j
    addu    t4, t3, t7        // t4 = t3 + j(t7)，计算[i][j]对应元素的偏移量

    addu     t5, t4, v0       // t5 = base(arr)+ t4，计算[i][j]对应元素存储地址

    sb      a3, 0(t5)         // arr[i][k]+arr[k][j]保存到arr[i][j]对应存储空间位置
    nop                       // 延迟隙，插入空操作
4:
  /* 下面的代码判断最内侧循环是否结束 */
    bne    t2,v1, 3b          // (t2)=(v1)?，不相等则跳转到标号3的位置
    nop                       // 延迟隙，插入空操作

  /* 下面的代码判断中间循环是否结束 */
    li      t2, 0             // 寄存器t2初始化为0
    bne     t1,v1, 2b         // (t1)=(v1)?，不相等则跳转到标号2的位置
    nop                       // 延迟隙，插入空操作

  /* 下面的代码判断哦最外层循环是否结束 */
    li      t1, 0             // 寄存器t1初始化为0
    bne     t0,v1, 1b         // (t0)=(v1)?，不相等则跳转到标号1的位置
    nop                       // 延迟隙，插入空操作

    move    ra, s0            // 恢复返回地址
    j       ra                // 跳转到寄存器ra所保存的目标地址
    nop                       // 延迟隙，插入空操作

	.set reorder
ENDFRAME(bsp_start)


